<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>NVIDIA GameWorks Graphics App Framework and Libraries: NvImage Class Reference</title>

<!doctype html>
<html class="csstransforms csstransforms3d csstransitions" lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta charset="utf-8" />
	<title>NVIDIA GameWorks Graphics App Framework and Libraries: NvImage Class Reference</title>
	<meta name="description" content="NVIDIA GameWorks Graphics App Framework and Libraries: NvImage Class Reference" />
	<!-- CSS files -->
	<link href="tabs.css" rel="stylesheet" type="text/css" />
	<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
    <link href="../../css/application.css" rel="stylesheet" type="text/css" />
    <link href="../../css/styleguide.css" rel="stylesheet" type="text/css" />
	<!--<link rel="stylesheet" type="text/css" href="sdk_samples.css" />-->
	<!-- scripts to include -->
    <script src="../../js/jquery.js"></script>
    <script src="../../js/owl.carousel.js"></script>
    <script src="../../js/jquery.fitvids.js"></script>
    <script src="../../js/jquery.colorbox.js"></script>
    <script src="../../js/jquery.isotope.js"></script>
    <script src="../../js/jquery.sidr.js"></script>
    <script src="../../js/bootstrap.js"></script>
    <script src="../../js/application.js"></script>
    <script src="../../js/prettify.js"></script>
</head>


<body style="">

<!--Navbar-->
<nav class="navbar navbar-inverse navbar-static-top" role="navigation">
  <div class="container">
	<div class="navbar-header" style="">
	  <!--<button class="navbar-toggle" type="button"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button>-->
	  <div class="logo-header">
		<a class="navbar-brand logo" href="http://developer.nvidia.com/gameworks"><img alt="NVidia Gameworks" height="21" src="../../images/developerzone_gameworks_logo.png" usemap="#logo-header" width="245"></a>
	  </div>
	</div>
  </div>
</nav>

<!-- main body block -->
<div id="content" class="container">
	<div class="seperator"></div>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>NvImage Class Reference</h1><!-- doxytag: class="NvImage" -->Image loading, representation and handling Support loading of images from DDS files and data, including cube maps, arrays mipmap levels, formats, etc.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="_nv_image_8h-source.html">NvImage.h</a>&gt;</code>
<p>

<p>
<a href="class_nv_image-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_image_1_1_format_info.html">FormatInfo</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Format handlers descriptor for custom image loading.  <a href="struct_nv_image_1_1_format_info.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_image.html#5ea2bb68488ab170831cfe30479c4404">getWidth</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The image width in pixels.  <a href="#5ea2bb68488ab170831cfe30479c4404"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_image.html#ed511686df73c4951250e51b658c56bd">getHeight</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The image height in pixels.  <a href="#ed511686df73c4951250e51b658c56bd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_image.html#edae3b23e567f7db547492fb2a4263d1">getDepth</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The image depth in pixels.  <a href="#edae3b23e567f7db547492fb2a4263d1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_image.html#049d4af9cc738cce7834074786bae74e">getMipLevels</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The number of miplevels.  <a href="#049d4af9cc738cce7834074786bae74e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_image.html#d9f7082a78457233d20eeb6e0e57b9a2">getFaces</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The number of cubemap faces.  <a href="#d9f7082a78457233d20eeb6e0e57b9a2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_image.html#da49513b228c770a6e96b175f708c1c2">getLayers</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The number of layers in a texture array.  <a href="#da49513b228c770a6e96b175f708c1c2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_image.html#d26de1351d2b1c1bc621a8ffa83d8188">getFormat</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The GL format of the image.  <a href="#d26de1351d2b1c1bc621a8ffa83d8188"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_image.html#f8465fe90b8495db35f2cc809aba4630">getInternalFormat</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The GL internal format of the image.  <a href="#f8465fe90b8495db35f2cc809aba4630"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_image.html#620ef2ef1be2f89706be890461b58322">getType</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The GL type of the pixel data.  <a href="#620ef2ef1be2f89706be890461b58322"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_image.html#696d5c5a365b9a7ad72ce0cae9e37554">getImageSize</a> (int32_t level=0) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The size (in bytes) of a selected mipmap level of the image.  <a href="#696d5c5a365b9a7ad72ce0cae9e37554"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_image.html#3b3467058ebb16a1683fd7a046ac501d">isCompressed</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Whether or not the image is compressed.  <a href="#3b3467058ebb16a1683fd7a046ac501d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_image.html#ef396ef13d016045b877cc1a1dd4c504">isCubeMap</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Whether or not the image is a cubemap.  <a href="#ef396ef13d016045b877cc1a1dd4c504"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_image.html#9033a4e6e3638d0d1f296de5be6631d8">hasAlpha</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Whether or not the image's pixel format has an explicit alpha channel.  <a href="#9033a4e6e3638d0d1f296de5be6631d8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_image.html#0f9b6ea2dfe69ae2856123ec88aa738a">isArray</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Whether or not the image is an array texture.  <a href="#0f9b6ea2dfe69ae2856123ec88aa738a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_image.html#d72e9eb81a2ce5d0695f35ae42c0e2e9">isVolume</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Whether or not the image is a volume (3D) image.  <a href="#d72e9eb81a2ce5d0695f35ae42c0e2e9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_image.html#1917ed5898cb2c160379b3feb914c348">getDataBlockSize</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the size of the overall pixel data block for the image.  <a href="#1917ed5898cb2c160379b3feb914c348"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_image.html#7ea07a2863f6ff25fb8ad385fc53f5e7">loadImageFromFileData</a> (const uint8_t *fileData, size_t size, const char *fileExt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Loads an image from file-formatted data.  <a href="#7ea07a2863f6ff25fb8ad385fc53f5e7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_image.html#b892c768859283dbb91ad5db05652b0b">convertCrossToCubemap</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a flat "cross" image to a cubemap Convert a suitable image from a cubemap cross to a cubemap.  <a href="#b892c768859283dbb91ad5db05652b0b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_image.html#a73d67c3e9030806255ab4c48743a5ee">reformatImage</a> (int32_t width, int32_t height, uint32_t format, uint32_t type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replace (destructive to all content) the storage data and format of the image Mainly used by image loaders to resize and reformat an already-created image.  <a href="#a73d67c3e9030806255ab4c48743a5ee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="585bc54b57eb772c75b4230675d01e4c"></a><!-- doxytag: member="NvImage::setImage" ref="585bc54b57eb772c75b4230675d01e4c" args="(int32_t width, int32_t height, uint32_t format, uint32_t type, const void *data)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>setImage</b> (int32_t width, int32_t height, uint32_t format, uint32_t type, const void *data)</td></tr>

<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_image.html#0896e45b312fcf48f07b82cde77dadcd">getLevel</a> (int32_t level) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_image.html#f0844130f5e71c5acc15d6c6eac26857">getLevel</a> (int32_t level)</td></tr>

<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_image.html#d0a2de5df634a5b4b4592b033e7a6a5c">getLevel</a> (int32_t level, uint32_t face) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_image.html#194bf3e72c9b5f898c5afed96edc350c">getLevel</a> (int32_t level, uint32_t face)</td></tr>

<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_image.html#3942266e122af5c632da755c8fa08125">getLayerLevel</a> (int32_t level, int32_t slice) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_image.html#118a5c6a8eb7fac6ba3bde8cb56ad6a3">getLayerLevel</a> (int32_t level, int32_t slice)</td></tr>

<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const uint8_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_image.html#392e9c80ed35e6313a2b18411f8de39a">getDataBlock</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">uint8_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_image.html#770d951867d985efbec6476f9c1d434f">getDataBlock</a> ()</td></tr>

<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_image.html#ba0b837fea308d311a65028c8be47fc0">getLevelOffset</a> (int32_t level) const </td></tr>

<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_image.html#13b1306bd0846e5302914e970bd5dad1">getLevelOffset</a> (int32_t level, uint32_t face) const </td></tr>

<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_image.html#5571733612fcc7f467abceeedaa505ab">getLayerLevelOffset</a> (int32_t level, int32_t slice) const </td></tr>

<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_image.html#116d20c8867c9df12663dbe8a233bf94">VerticalFlip</a> (bool flip)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets whether to flip the image vertically.  <a href="#116d20c8867c9df12663dbe8a233bf94"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_image.html#b4e6936c1b271e8236d817c62d130c28">GetVerticalFlip</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether the loader will flip the image vertically.  <a href="#b4e6936c1b271e8236d817c62d130c28"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="class_nv_image.html">NvImage</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_image.html#cd31d05504bef29e3c16bd5307c844b4">CreateFromDDSFile</a> (const char *filename)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new <a class="el" href="class_nv_image.html" title="Image loading, representation and handling Support loading of images from DDS files...">NvImage</a> (no texture) directly from DDS file Uses <a class="el" href="_nv_asset_loader_8h.html#f84eaa6db008c8acdcfa5d4333e8da58" title="Reads an asset file as a block.">NvAssetLoaderRead</a> for opening the file.  <a href="#cd31d05504bef29e3c16bd5307c844b4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_image.html#1ec8ddf20497e516ac9f40c38c7ca65f">setSupportsBGR</a> (bool bgr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables or disables automatic swapping of BGR-order images to RGB.  <a href="#1ec8ddf20497e516ac9f40c38c7ca65f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_image.html#834e81801abf7141554e86f51c0e5f25">getSupportsBGR</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the status of automatic swapping of BGR-order images to RGB.  <a href="#834e81801abf7141554e86f51c0e5f25"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_image.html#649ac5c8a11f3c7fce25df7187cb93fc">setDXTExpansion</a> (bool expand)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables or disables automatic expansion of DXT images to RGBA.  <a href="#649ac5c8a11f3c7fce25df7187cb93fc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_image.html#3c4f922a82aa52107b67f1b1cca6e4a2">getDXTExpansion</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the status of automatic DXT expansion.  <a href="#3c4f922a82aa52107b67f1b1cca6e4a2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_image.html#dda7823c13309aa3b63cf92fbfee7b2e">addFileLoader</a> (const <a class="el" href="struct_nv_image_1_1_format_info.html">FormatInfo</a> &amp;loader)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a file loader for the given file extension.  <a href="#dda7823c13309aa3b63cf92fbfee7b2e"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3b5361371c55064542252ad461327cf1"></a><!-- doxytag: member="NvImage::TranslateDX10Format" ref="3b5361371c55064542252ad461327cf1" args="(const void *ptr, NvImage &amp;i, int32_t &amp;bytesPerElement, bool &amp;btcCompressed)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>TranslateDX10Format</b> (const void *ptr, <a class="el" href="class_nv_image.html">NvImage</a> &amp;i, int32_t &amp;bytesPerElement, bool &amp;btcCompressed)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Image loading, representation and handling Support loading of images from DDS files and data, including cube maps, arrays mipmap levels, formats, etc. 
<p>
The class does NOT encapsulate a rendering texture object, only the client side pixel data that could be used to create such a texture <hr><h2>Member Function Documentation</h2>
<a class="anchor" name="dda7823c13309aa3b63cf92fbfee7b2e"></a><!-- doxytag: member="NvImage::addFileLoader" ref="dda7823c13309aa3b63cf92fbfee7b2e" args="(const FormatInfo &amp;loader)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool NvImage::addFileLoader           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_nv_image_1_1_format_info.html">FormatInfo</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>loader</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a file loader for the given file extension. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>loader</em>&nbsp;</td><td>the descriptor for the loading system </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true on success or false on failure (no more loader slots or extension already handled) </dd></dl>

</div>
</div><p>
<a class="anchor" name="b892c768859283dbb91ad5db05652b0b"></a><!-- doxytag: member="NvImage::convertCrossToCubemap" ref="b892c768859283dbb91ad5db05652b0b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NvImage::convertCrossToCubemap           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert a flat "cross" image to a cubemap Convert a suitable image from a cubemap cross to a cubemap. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true on success or false for unsuitable source images </dd></dl>

</div>
</div><p>
<a class="anchor" name="cd31d05504bef29e3c16bd5307c844b4"></a><!-- doxytag: member="NvImage::CreateFromDDSFile" ref="cd31d05504bef29e3c16bd5307c844b4" args="(const char *filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_nv_image.html">NvImage</a>* NvImage::CreateFromDDSFile           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>filename</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new <a class="el" href="class_nv_image.html" title="Image loading, representation and handling Support loading of images from DDS files...">NvImage</a> (no texture) directly from DDS file Uses <a class="el" href="_nv_asset_loader_8h.html#f84eaa6db008c8acdcfa5d4333e8da58" title="Reads an asset file as a block.">NvAssetLoaderRead</a> for opening the file. 
<p>
See the documentation for that package to understand the correct paths <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filename</em>&nbsp;</td><td>the image filename (and path) to load </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a pointer to the <a class="el" href="class_nv_image.html" title="Image loading, representation and handling Support loading of images from DDS files...">NvImage</a> representing the file or null on failure </dd></dl>

</div>
</div><p>
<a class="anchor" name="770d951867d985efbec6476f9c1d434f"></a><!-- doxytag: member="NvImage::getDataBlock" ref="770d951867d985efbec6476f9c1d434f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* NvImage::getDataBlock           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a pointer to the overall pixel data block for the image. The block is contiguous and allows for easy loading into a single pre-allocated memory block for low-level 3D APIs <dl class="return" compact><dt><b>Returns:</b></dt><dd>a pointer to the data </dd></dl>

</div>
</div><p>
<a class="anchor" name="392e9c80ed35e6313a2b18411f8de39a"></a><!-- doxytag: member="NvImage::getDataBlock" ref="392e9c80ed35e6313a2b18411f8de39a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t* NvImage::getDataBlock           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a pointer to the overall pixel data block for the image. The block is contiguous and allows for easy loading into a single pre-allocated memory block for low-level 3D APIs <dl class="return" compact><dt><b>Returns:</b></dt><dd>a pointer to the data </dd></dl>

</div>
</div><p>
<a class="anchor" name="1917ed5898cb2c160379b3feb914c348"></a><!-- doxytag: member="NvImage::getDataBlockSize" ref="1917ed5898cb2c160379b3feb914c348" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t NvImage::getDataBlockSize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the size of the overall pixel data block for the image. 
<p>
The block is contiguous and allows for easy loading into a single pre-allocated memory block for low-level 3D APIs <dl class="return" compact><dt><b>Returns:</b></dt><dd>the size of the block in bytes </dd></dl>

</div>
</div><p>
<a class="anchor" name="edae3b23e567f7db547492fb2a4263d1"></a><!-- doxytag: member="NvImage::getDepth" ref="edae3b23e567f7db547492fb2a4263d1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t NvImage::getDepth           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The image depth in pixels. 
<p>
This is the third dimension of a 3D/volume image, NOT the color-depth <dl class="return" compact><dt><b>Returns:</b></dt><dd>the depth of the image (0 for images with no depth) </dd></dl>

</div>
</div><p>
<a class="anchor" name="3c4f922a82aa52107b67f1b1cca6e4a2"></a><!-- doxytag: member="NvImage::getDXTExpansion" ref="3c4f922a82aa52107b67f1b1cca6e4a2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool NvImage::getDXTExpansion           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the status of automatic DXT expansion. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if DXT images will be expanded, false if they will be passed through </dd></dl>

</div>
</div><p>
<a class="anchor" name="d9f7082a78457233d20eeb6e0e57b9a2"></a><!-- doxytag: member="NvImage::getFaces" ref="d9f7082a78457233d20eeb6e0e57b9a2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t NvImage::getFaces           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The number of cubemap faces. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of cubemap faces available for the image (0 for non-cubemap images) </dd></dl>

</div>
</div><p>
<a class="anchor" name="d26de1351d2b1c1bc621a8ffa83d8188"></a><!-- doxytag: member="NvImage::getFormat" ref="d26de1351d2b1c1bc621a8ffa83d8188" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t NvImage::getFormat           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The GL format of the image. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the format of the image data (NVIMAGE_RGB, NVIMAGE_BGR, etc) </dd></dl>

</div>
</div><p>
<a class="anchor" name="ed511686df73c4951250e51b658c56bd"></a><!-- doxytag: member="NvImage::getHeight" ref="ed511686df73c4951250e51b658c56bd" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t NvImage::getHeight           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The image height in pixels. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the height of the image in pixels </dd></dl>

</div>
</div><p>
<a class="anchor" name="696d5c5a365b9a7ad72ce0cae9e37554"></a><!-- doxytag: member="NvImage::getImageSize" ref="696d5c5a365b9a7ad72ce0cae9e37554" args="(int32_t level=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t NvImage::getImageSize           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>level</em> = <code>0</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The size (in bytes) of a selected mipmap level of the image. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the Size in bytes of a level of the image </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>level</em>&nbsp;</td><td>the mipmap level whose size if to be returned </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f8465fe90b8495db35f2cc809aba4630"></a><!-- doxytag: member="NvImage::getInternalFormat" ref="f8465fe90b8495db35f2cc809aba4630" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t NvImage::getInternalFormat           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The GL internal format of the image. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the suggested internal format for the data </dd></dl>

</div>
</div><p>
<a class="anchor" name="118a5c6a8eb7fac6ba3bde8cb56ad6a3"></a><!-- doxytag: member="NvImage::getLayerLevel" ref="118a5c6a8eb7fac6ba3bde8cb56ad6a3" args="(int32_t level, int32_t slice)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* NvImage::getLayerLevel           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>slice</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a pointer to the pixel data for a given mipmap level and array slice. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>level</em>&nbsp;</td><td>the mipmap level [0, <a class="el" href="class_nv_image.html#049d4af9cc738cce7834074786bae74e" title="The number of miplevels.">getMipLevels</a>) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>slice</em>&nbsp;</td><td>the layer index [0, <a class="el" href="class_nv_image.html#da49513b228c770a6e96b175f708c1c2" title="The number of layers in a texture array.">getLayers</a>) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a pointer to the data </dd></dl>

</div>
</div><p>
<a class="anchor" name="3942266e122af5c632da755c8fa08125"></a><!-- doxytag: member="NvImage::getLayerLevel" ref="3942266e122af5c632da755c8fa08125" args="(int32_t level, int32_t slice) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void* NvImage::getLayerLevel           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>slice</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a pointer to the pixel data for a given mipmap level and array slice. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>level</em>&nbsp;</td><td>the mipmap level [0, <a class="el" href="class_nv_image.html#049d4af9cc738cce7834074786bae74e" title="The number of miplevels.">getMipLevels</a>) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>slice</em>&nbsp;</td><td>the layer index [0, <a class="el" href="class_nv_image.html#da49513b228c770a6e96b175f708c1c2" title="The number of layers in a texture array.">getLayers</a>) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a pointer to the data </dd></dl>

</div>
</div><p>
<a class="anchor" name="5571733612fcc7f467abceeedaa505ab"></a><!-- doxytag: member="NvImage::getLayerLevelOffset" ref="5571733612fcc7f467abceeedaa505ab" args="(int32_t level, int32_t slice) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t NvImage::getLayerLevelOffset           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>slice</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an offset in bytes from the block base to the pixel data for a given mipmap level and array slice. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>level</em>&nbsp;</td><td>the mipmap level [0, <a class="el" href="class_nv_image.html#049d4af9cc738cce7834074786bae74e" title="The number of miplevels.">getMipLevels</a>) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>slice</em>&nbsp;</td><td>the layer index [0, <a class="el" href="class_nv_image.html#da49513b228c770a6e96b175f708c1c2" title="The number of layers in a texture array.">getLayers</a>) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the offset in bytes </dd></dl>

</div>
</div><p>
<a class="anchor" name="da49513b228c770a6e96b175f708c1c2"></a><!-- doxytag: member="NvImage::getLayers" ref="da49513b228c770a6e96b175f708c1c2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t NvImage::getLayers           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The number of layers in a texture array. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of layers for use in texture arrays </dd></dl>

</div>
</div><p>
<a class="anchor" name="194bf3e72c9b5f898c5afed96edc350c"></a><!-- doxytag: member="NvImage::getLevel" ref="194bf3e72c9b5f898c5afed96edc350c" args="(int32_t level, uint32_t face)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* NvImage::getLevel           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>face</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a pointer to the pixel data for a given mipmap level and cubemap face. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>level</em>&nbsp;</td><td>the mipmap level [0, getMipLevels) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>face</em>&nbsp;</td><td>the cubemap face (NVIMAGE_TEXTURE_CUBE_MAP_*_*) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a pointer to the data </dd></dl>

</div>
</div><p>
<a class="anchor" name="d0a2de5df634a5b4b4592b033e7a6a5c"></a><!-- doxytag: member="NvImage::getLevel" ref="d0a2de5df634a5b4b4592b033e7a6a5c" args="(int32_t level, uint32_t face) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void* NvImage::getLevel           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>face</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a pointer to the pixel data for a given mipmap level and cubemap face. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>level</em>&nbsp;</td><td>the mipmap level [0, getMipLevels) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>face</em>&nbsp;</td><td>the cubemap face (NVIMAGE_TEXTURE_CUBE_MAP_*_*) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a pointer to the data </dd></dl>

</div>
</div><p>
<a class="anchor" name="f0844130f5e71c5acc15d6c6eac26857"></a><!-- doxytag: member="NvImage::getLevel" ref="f0844130f5e71c5acc15d6c6eac26857" args="(int32_t level)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* NvImage::getLevel           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>level</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a pointer to the pixel data for a given mipmap level. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>level</em>&nbsp;</td><td>the mipmap level [0, getMipLevels) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a pointer to the data </dd></dl>

</div>
</div><p>
<a class="anchor" name="0896e45b312fcf48f07b82cde77dadcd"></a><!-- doxytag: member="NvImage::getLevel" ref="0896e45b312fcf48f07b82cde77dadcd" args="(int32_t level) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void* NvImage::getLevel           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>level</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a pointer to the pixel data for a given mipmap level. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>level</em>&nbsp;</td><td>the mipmap level [0, getMipLevels) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a pointer to the data </dd></dl>

</div>
</div><p>
<a class="anchor" name="13b1306bd0846e5302914e970bd5dad1"></a><!-- doxytag: member="NvImage::getLevelOffset" ref="13b1306bd0846e5302914e970bd5dad1" args="(int32_t level, uint32_t face) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t NvImage::getLevelOffset           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>face</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an offset in bytes from the block base to the pixel data for a given mipmap level and array slice. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>level</em>&nbsp;</td><td>the mipmap level [0, <a class="el" href="class_nv_image.html#049d4af9cc738cce7834074786bae74e" title="The number of miplevels.">getMipLevels</a>) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>slice</em>&nbsp;</td><td>the layer index [0, <a class="el" href="class_nv_image.html#da49513b228c770a6e96b175f708c1c2" title="The number of layers in a texture array.">getLayers</a>) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the offset in bytes </dd></dl>

</div>
</div><p>
<a class="anchor" name="ba0b837fea308d311a65028c8be47fc0"></a><!-- doxytag: member="NvImage::getLevelOffset" ref="ba0b837fea308d311a65028c8be47fc0" args="(int32_t level) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t NvImage::getLevelOffset           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>level</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an offset in bytes from the block base to the pixel data for a given mipmap level. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>level</em>&nbsp;</td><td>the mipmap level [0, getMipLevels) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the offset in bytes </dd></dl>

</div>
</div><p>
<a class="anchor" name="049d4af9cc738cce7834074786bae74e"></a><!-- doxytag: member="NvImage::getMipLevels" ref="049d4af9cc738cce7834074786bae74e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t NvImage::getMipLevels           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The number of miplevels. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of mipmap levels available for the image </dd></dl>

</div>
</div><p>
<a class="anchor" name="834e81801abf7141554e86f51c0e5f25"></a><!-- doxytag: member="NvImage::getSupportsBGR" ref="834e81801abf7141554e86f51c0e5f25" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool NvImage::getSupportsBGR           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the status of automatic swapping of BGR-order images to RGB. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if BGR images will be swapped, false if they will be passed through </dd></dl>

</div>
</div><p>
<a class="anchor" name="620ef2ef1be2f89706be890461b58322"></a><!-- doxytag: member="NvImage::getType" ref="620ef2ef1be2f89706be890461b58322" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t NvImage::getType           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The GL type of the pixel data. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the type of the image data </dd></dl>

</div>
</div><p>
<a class="anchor" name="b4e6936c1b271e8236d817c62d130c28"></a><!-- doxytag: member="NvImage::GetVerticalFlip" ref="b4e6936c1b271e8236d817c62d130c28" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool NvImage::GetVerticalFlip           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns whether the loader will flip the image vertically. 
<p>
By default, the image library places the origin of images at the lower-left corner, to make it map exactly to OpenGL screen coords. This might make it incompatible with the texture coordinate conventions of an imported model that places its origin at the upper-left corner (D3D/DDS). In that case, doing a flip during loading could be desirable. <dl class="return" compact><dt><b>Returns:</b></dt><dd>true if flip is enabled. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5ea2bb68488ab170831cfe30479c4404"></a><!-- doxytag: member="NvImage::getWidth" ref="5ea2bb68488ab170831cfe30479c4404" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t NvImage::getWidth           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The image width in pixels. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the width of the image in pixels </dd></dl>

</div>
</div><p>
<a class="anchor" name="9033a4e6e3638d0d1f296de5be6631d8"></a><!-- doxytag: member="NvImage::hasAlpha" ref="9033a4e6e3638d0d1f296de5be6631d8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NvImage::hasAlpha           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Whether or not the image's pixel format has an explicit alpha channel. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>boolean whether the image has explicit alpha channel </dd></dl>

</div>
</div><p>
<a class="anchor" name="0f9b6ea2dfe69ae2856123ec88aa738a"></a><!-- doxytag: member="NvImage::isArray" ref="0f9b6ea2dfe69ae2856123ec88aa738a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NvImage::isArray           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Whether or not the image is an array texture. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>boolean whether the image represents a texture array </dd></dl>

</div>
</div><p>
<a class="anchor" name="3b3467058ebb16a1683fd7a046ac501d"></a><!-- doxytag: member="NvImage::isCompressed" ref="3b3467058ebb16a1683fd7a046ac501d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NvImage::isCompressed           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Whether or not the image is compressed. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>boolean whether the data is a crompressed format </dd></dl>

</div>
</div><p>
<a class="anchor" name="ef396ef13d016045b877cc1a1dd4c504"></a><!-- doxytag: member="NvImage::isCubeMap" ref="ef396ef13d016045b877cc1a1dd4c504" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NvImage::isCubeMap           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Whether or not the image is a cubemap. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>boolean whether the image represents a cubemap </dd></dl>

</div>
</div><p>
<a class="anchor" name="d72e9eb81a2ce5d0695f35ae42c0e2e9"></a><!-- doxytag: member="NvImage::isVolume" ref="d72e9eb81a2ce5d0695f35ae42c0e2e9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NvImage::isVolume           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Whether or not the image is a volume (3D) image. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>boolean whether the image represents a volume </dd></dl>

</div>
</div><p>
<a class="anchor" name="7ea07a2863f6ff25fb8ad385fc53f5e7"></a><!-- doxytag: member="NvImage::loadImageFromFileData" ref="7ea07a2863f6ff25fb8ad385fc53f5e7" args="(const uint8_t *fileData, size_t size, const char *fileExt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NvImage::loadImageFromFileData           </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&nbsp;</td>
          <td class="paramname"> <em>fileData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fileExt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Loads an image from file-formatted data. 
<p>
Initialize an image from file-formatted memory; only DDS files are supported <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fileData</em>&nbsp;</td><td>the block of memory representing the entire image file </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>size</em>&nbsp;</td><td>the size of the data block in bytes </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fileExt</em>&nbsp;</td><td>the file extension string; must be "dds" </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true on success, false on failure </dd></dl>

</div>
</div><p>
<a class="anchor" name="a73d67c3e9030806255ab4c48743a5ee"></a><!-- doxytag: member="NvImage::reformatImage" ref="a73d67c3e9030806255ab4c48743a5ee" args="(int32_t width, int32_t height, uint32_t format, uint32_t type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NvImage::reformatImage           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Replace (destructive to all content) the storage data and format of the image Mainly used by image loaders to resize and reformat an already-created image. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>width</em>&nbsp;</td><td>of the new image </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>height</em>&nbsp;</td><td>of the new image </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>format</em>&nbsp;</td><td>NVIMAGE_ format of the new image </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>type</em>&nbsp;</td><td>NVIMAGE_ type of the component data in the new image </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true on success or false for failure </dd></dl>

</div>
</div><p>
<a class="anchor" name="649ac5c8a11f3c7fce25df7187cb93fc"></a><!-- doxytag: member="NvImage::setDXTExpansion" ref="649ac5c8a11f3c7fce25df7187cb93fc" args="(bool expand)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void NvImage::setDXTExpansion           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>expand</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enables or disables automatic expansion of DXT images to RGBA. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>expand</em>&nbsp;</td><td>true enables DXT-to-RGBA expansion. False passes DXT images through as-is </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1ec8ddf20497e516ac9f40c38c7ca65f"></a><!-- doxytag: member="NvImage::setSupportsBGR" ref="1ec8ddf20497e516ac9f40c38c7ca65f" args="(bool bgr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void NvImage::setSupportsBGR           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>bgr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enables or disables automatic swapping of BGR-order images to RGB. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bgr</em>&nbsp;</td><td>true allows BGR directly. False causes the loader to reformat to RGB </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="116d20c8867c9df12663dbe8a233bf94"></a><!-- doxytag: member="NvImage::VerticalFlip" ref="116d20c8867c9df12663dbe8a233bf94" args="(bool flip)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void NvImage::VerticalFlip           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>flip</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets whether to flip the image vertically. 
<p>
By default, the image library places the origin of images at the lower-left corner, to make it map exactly to OpenGL screen coords. This might make it incompatible with the texture coordinate conventions of an imported model that places its origin at the upper-left corner (D3D/DDS). In that case, doing a flip during loading could be desirable. Note: for ASTC textures, flip is not supported and "VerticalFlip(false)" is required. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flip</em>&nbsp;</td><td>true if flip is required. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_nv_image_8h-source.html">NvImage.h</a></ul>
</div>
</div> <!--content-->
<!-- footer block-->
<div id="footer" class="container">
	<div class="seperator"></div>
	<div class="seperator"></div>
	<address style="text-align: right;"><small>
Generated on Fri Apr 6 12:40:25 2018 for NVIDIA GameWorks Graphics App Framework and Libraries by&nbsp;<a href="http://www.doxygen.org/index.html">Doxygen</a></small></address>
	<footer>
		<div class="row">
			<div class="text-center">&copy;2016 NVIDIA Corporation.</div>
			<div class="seperator"></div>
		</div>
	</footer>
</div> <!--footer-->

</body>
</html>
